datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  image     String?
  points    Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdRooms Room[]       @relation("RoomCreator")
  participants RoomPlayer[]
  responses    Response[]
  votes        Vote[]
  medals       Medal[]

  @@map("users")
}
model Medal {
  id        String     @id @default(cuid())
  type      MedalType
  createdAt DateTime   @default(now())

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  room      Room       @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId    String

  @@map("medals")
}

enum MedalType {
  FIRST_PLACE
  SECOND_PLACE
  THIRD_PLACE
}
model Room {
  id          String      @id @default(cuid())
  name        String
  code        String      @unique  
  maxPlayers  Int         @default(6)
  status      RoomStatus  @default(WAITING)

  upvotesPerPlayer   Int      @default(3)          
  downvotesPerPlayer Int      @default(1)          
  
  allowedCategories  Category[]
  totalRounds        Int      @default(7)

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  creator     User        @relation("RoomCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  creatorId   String

  players     RoomPlayer[]
  rounds      Round[]
  themes      Theme[]
  medals      Medal[]

  @@map("rooms")
}

enum RoomStatus {
  WAITING
  PLAYING
  FINISHED
}

model RoomPlayer {
  id        String   @id @default(cuid())
  score     Int      @default(0)
  joinedAt  DateTime @default(now())

  room      Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId    String

  player    User     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId  String

  @@unique([roomId, playerId])
  @@map("room_players")
}

model Round {
  id            String      @id @default(cuid())
  roundNumber   Int
  status        RoundStatus @default(SUBMITTING)
  startedAt     DateTime?
  endedAt       DateTime?
  createdAt     DateTime    @default(now())

  room          Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId        String

  theme         Theme       @relation(fields: [themeId], references: [id])
  themeId       String

  responses     Response[]

  @@unique([roomId, roundNumber])
  @@map("rounds")
}

enum RoundStatus {
  SUBMITTING
  VOTING
  FINISHED
}

model Theme {
  id          String    @id @default(cuid())
  title       String
  description String?
  category    Category?
  isSystem    Boolean   @default(false)
  createdAt   DateTime  @default(now())

  room        Room?     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId      String?

  rounds      Round[]

  @@map("themes")
}

enum Category {
  TEXT
  IMAGE
  PHOTO
  VIDEO
  AUDIO
  DRAWING
}

model Response {
  id          String    @id @default(cuid())
  content     String
  mediaUrl    String?
  category    Category
  createdAt   DateTime  @default(now())

  round       Round     @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId     String

  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String

  upvotes     Int       @default(0)      
  downvotes   Int       @default(0)
  votes       Vote[]

  @@unique([roundId, authorId])
  @@map("responses")
}

model Vote {
  id         String   @id @default(cuid())
  type       VoteType
  createdAt  DateTime @default(now())

  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  responseId String

  voter      User     @relation(fields: [voterId], references: [id], onDelete: Cascade)
  voterId    String
  
  @@unique([responseId, voterId])
  @@map("votes")
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}